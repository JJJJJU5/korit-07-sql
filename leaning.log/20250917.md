# 복습

```sql
SELECT u.id,u.username,u.phone,o.id,od.product_id
FROM users u
left JOIN orders o
ON u.id = o.user_id
inner JOIN orderdetails od
ON o.id = od.order_id
order by u.id
```

- FROM 내에서는 JOIM을 중첩해서 사용 가능. 이상의 경우에서는 첫 번째 JOIN의 ON 절 뒤에, 두 번째 JOIN을 작성했다고 볼 수 있다. 필요한 정보가 셋 이상의 테이블에 나뉘어 있어도, 키 값을 기반으로 연결할 수 있다면 한 번에 조회할 수 있다(근데 서브쿼리를 배우면 서브쿼리를 사용하겠다고 망치는 경우도 종종 있다.) 예제 쿼리는 LEFT Join을 통해 주문 정보가 없는 회원의 주문 정보를 포함했고, INNER JOIN을 통해 orders / orderdetails의 교집합 정보만을 출력했다.
  - 확인해보면 orders에 주문을 했어야 주문 세부 사항이 나오니 left Join을 사용했어도 결과의 차이는 없다.

예제 : users와 orders를 하나로 결합하는데, 회원 정보가 없는 주문 정보도 출력할 수 있도록 작성하시오.

```sql
select *
from users u RIGHT JOIN orders o
ON u.id = o.user_id
order by u.id
```

이상의 경우에서는 차집합 개념을 들 수 있는데, 그렇다면 LEFT JOIN과 동일한 기능을 하는 것처럼 보인다. 하지만 INNER JOIN과 결과값이 같다(즉, 주문 내역이 없는 회원의 정보는 출력되지 않았음을 의미한다.)

그래서 LEFT JOIN과 명확히 동일한 결과값을 만들기 위해서는 테이블 순서를 바꿀 필요가 있다.
이상과 같은 이유로 많은 기업에서는 RIGHT JOIN 대신에 LEFT JOIN만 사용하도록 권장하는 편이다.
먼저 나온 테이블이 기준이 되도록 해서 LEFT JOIN만 사용하거나 , 아니면 교집합만 사용하기 위해 INNER JOIN만 사용한다고 봐도 무방하다.

예제 : users와 orders의 _모든 가능한 행 조합_ 을 만들어내는 SQL 쿼리를 작성하시오.

```sql
SELECT *
  FROM user u CROSS JOIN orders o
  order by u.id
```

- CROSS JOIN은 두 집합을 _조합_ 해 만들 수 있는 _카테시안 곱(cartesian product)_ 을 출력한다. 순서는 u.id를 기준으로 작성했다.
  모든 조합이 나오기 떄문에 LEFT / RIGHT / INNER JOIN 처럼 u.id = o.user*id 같은 조건 없이 두 테이블의 모든 행을 합쳐서 만들 수 있는 모든 경우의 수를 출력한다.
  그렇다면 10개의 row를 지니는 테이블과 20개의 row를 지니는 테이블을 CROSS JOIN 하면
  10 \* 20 으로 200개의 row를 지니는 행이 나오며 , 이외의 경우의 수는 존재하지 않는다.
  *모든* 이 매우 중요하다. *조건\_ 이없다.

이상을 이유로 실제 운영 환경에서는 CROSS JOIN을 제한하는 편이다. 컴퓨터의 리소스를 많이 사용하는데다가 실용성이 떨어지기 때문

그리고 CROSS JOIN과 유사해보이기는 하지만 조금 다른 (FULL OUTER JOIN)도 존재한다.

FUll OUTER JOIN = LEFT JOIN + RIGHT JOIN - INNER JOIN

# JOIN 정리하기

- JOIN은 복수의 테이블을 하나로 결합할 때 사용. 여러 곳에 기록된(정규화된) 데이터를 마치 하나의 테이블 처럼 합칠 때 필요.

형식 :

```sql
from
  테이블1 a(LEFT/INNER) Join 테이블 2 b
  on a.pk = b.fk;
```

join은 from 절에서 수행된다. 그렇다면 _가장 먼저_ 실행된다고 볼 수 있다.
join 이후 나머지 WHERE, GROUP by. HAVING , SELECT , ORDER BY가 실행되기 때문에 FROM 절에서 지정한 표의 별칭을 이후 제어문에서 전부 사용이 가능하다.

또한 조건에서 볼 수 있듯이 _공통된 컬럼 값인 키 값_ 이 존재해야지만 JOIN으로 결합 할 수 있다. 키 값은 여러 개가 있을 수 있어, 어떤 값을 기준으로 할지 ON에서 명시한다.(에제에서는 PK / FK가 하나씩이다.)

JOIN 중첩하기

```sql
FROM 테이블1 a
  (LEFT / INNER ) JOIN
  테이블2 b
  On a.pk = b.fk
  (left / inner)JOIn          # 참고로 ON 뒤에 pk 쪽을 써주는 것이 관례
  테이블3 c
  on  조건 = c.fk
```

- INNER JOIN : 각 테이블의 키 값이 일치하는 행만(교집합만) 출력함. 가장 기본적인 default JOIN이기 때문에 INNER 생략이 가능하다.
  그런데 가독성 문제로 명시적으로 INNER를 작성하는 것을 권장한다.

- LEFT JOIN : 왼쪽 테이블의 모든 데이터를 결과에 포함시켜서 출력.

- RIGHT JOIN : 오른쪽 테이블의 모든 데이터를 결과에 포함시켜서 출력.

- FULL OUTER JOIN : 좌우측 테이블의 모든 데이터를 결과에 포함시켜서 출력(CROSS와의 차이점)

- CROSS JOIN

```sql
from
  테이블1 a CROSS JOIN 테이블2 b
```

근데 사실 CROSS 쓸거면 조건이 필요없으니까 테이블 별칭이 없어도 되지 않냐 싶을 수도 있는데,
SELECT에서 필요한 컬럼만 뽑아낼 때 쓰기 떄문에 조건이 없더라도 별칭을 정해주는 편.

FULL OUTER JOIN은 조건에 부합할 때만 결과값을 만들어내지만 CROSS JOIN은 모든 경우의 수를 전체 출력한다.

# 연슨 문제

1. users와 staff를 참고하여 회원 중 직원인 사람의 회원 아이디, 이메일, 거주 도시 ,거주 국가, 성, 이름을 한 화면에 출력하시오

```sql
SELECT u.id ,u.username,u.city,u.country,s.first_name,s.last_name
FROM users u
INNER JOIN staff s
ON u.id = s.user_id;
```

2. staff와 orders를 참고하여 직원 아이디가 3번, 5번인 직원의 담당 주문을 출력하시오
   (단 직원 아이디, 직원의 성, 주문 아이디 ,주문 일자만 출력할것)

```sql
SELECT s.id,s.last_name,o.id,o.order_date
FROM staff s
inner JOIN orders o
ON s.id = o.staff_id
WHERE s.id = 3 OR s.id =5
ORDER BY s.id;
```

3. users와 orders를 참고하여 회원 국가별 주문 건수를 내림차순으로 출력하시오.

```sql
SELECT u.country,COUNT(u.id) AS coCnt
FROM users u
INNER JOIN orders o
ON u.id = o.user_id
GROUP BY country
ORDER BY coCNt DESC;
```

4. orders와 orderdetails, products를 참고하여 회원 아이디 별 주문 금액을 총합을 정상 가격과 할인 가격 기준으로 각각 추출하시오.
   단 정상 가격 주문 금액의 총합 기준으로 내림 차순하시오.

```sql
SELECT o.user_id,ROund(SUM(p.price * od.quantity),1) AS u_price,round(SUM(p.discount_price * od.quantity),1) AS u_disprice
FROM products p
JOIN orderdetails od
ON p.id = od.product_id
JOIN orders o
ON o.id = od.order_id
GROUP BY o.user_id
ORDER BY u_price desc;
```

5. 다음 조건의 테이블이 있다고 가정합니다.

- 왼쪽 테이믈 A : 컬럼 개수 5개 / 150행
- 오른쪽 테이블 B : 컬럼 개수 7개 / 100행
- 두 테이블은 공통 키 값 컬럼을 1개 보유

이상의 조건의 두 테이블을 CROSS / LEFT / RIGHT / INNER JOIN으로 결합 햇을 때 결과 테이블의 행과 열 개수를 계산하시오.
각각 최소 / 최대를 기준으로 계산

1. CROSS JOIN : 150 \* 100 = 15000 rows / columns : 12
2. LEFT JOIN : 최소 150 rows / 최대 15000rows / columns : 12
3. RIGHT JOIN : 최소 100 rows / 최대 15000rows / columns : 12
4. INNER JOIN : 최소 0rows / 최대 15000rows / columns : 12

# UNION

## 컬럼 목록이 같은 데이터를 위아래로 결합

- 데이터를 위아래로 수직 결합을 지원하는 UNION 은 컬럼의 형식과 개수가 같은 두 데이터 결과 집합을 하나로 합친다고 볼 수 있다.
- 조건을 설정해서 결합해야하는 JOIN과 달리, UNION은 컬럼의 형식 / 개수만 동일하면
  어떻게든 결합이 가능하다.

예시 : users를 full scan한 결과 집합해서 UNION을 적용

```sql
(select * from users)
union
(select * from users)
```

이상의 쿼리를 실행해봤을 때 결과가 `SELECT * FROM users;`와 동일하다.
_UNION_ 은 중복 제거 기능이 있다.

예시 : users를 full scan한 결과 집합해서 UNION 적용( 중복 제거 수행 하지 않은 결과 값 출력할 것)

```sql
(select * from users)
union all
(select * from users)
order by id;
```

이상의 쿼리를 봤을 때 유니온의 기본 특성은 중복 제거에 있다 하지만 all을 사용하게 되면 중복을 제거하는 특성이 사라져 11,22,33 식으로 나오게 된다. UNION의 기본 전제 : 컬럼의 형식 / 개수 -> SELECT 수행 이후에 커스텀한 컬럼에서도 동일하게 적용된다.

```sql
(select * from users)
union all
(select id,phone,country,city from users)
```

이상의 쿼리를 실행 결과는 오류가 발생한다.
SQL문의 적용 순서에 관한 지식이 필요하다 결과적으로 select 문이 수행된 이후 결과값을 기준으로 UNION이 실행되기 때문에(소괄호가 적용된 부분이 먼저 수행된다.) 각각의 소괄호 1, 2의 연산 결과는 서로 다른 컬럼의 개수를 지니게 되기 때문에 UNION ALL 연산이 불가능해진다는 결과를 얻을 수 있다 -> 컬럼의 개수가 다르기 떄문에 연산 불가 -> 오류 발생

연습 : users에서 country가 Korea인 회원 정보만 추출하고, Mexico인 회원 정보만 추출하여 결합하시오.
컬럼은 id , phone , city , country만 추출하고, 최종 결과 집합은 country 기준 알파벳 순으로 정렬할 것.

```sql
SELECT u.id,u.phone,u.country,u.city
FROM users u
WHERE u.country IN ('Korea')
UNION
SELECT u.id,u.phone,u.country,u.city
FROM users u
WHERE u.country IN ('Mexico')
ORDER BY country asc
```

## UNION 정리

컬럼 형식 / 개수 조정이 중요하다.
중복 제거가 들어가있다.
중복 되어도 상관 없으면 UNION ALL을 사용한다.

연습 문제 :

1. orders에서 order_date가 2015년 10월 인 건과 2015년 12월인 건을 select로 각각 추출하고,
   두 결과 집합을 UNION ALL을 사용해 하나로 결합할 것

```sql
(SELECT o.order_date
FROM orders o
WHERE o.order_date BETWEEN '2015-10-01' AND '2015-10-31')
UNION ALL
(SELECT o.order_date
FROM orders o
WHERE o.order_date BETWEEN '2015-12-01' AND '2015-12-31');
```

2. users에서 USA에 거주 중이면서 마케팅 수신 동의를 한 회원 정보와 France에서 거주 중이면서 마케팅 수신에 동의하지 않은 회원 정보를 select로 각각 추출하고, 두 결과 집합을 UNION ALL을 사용해 하나로 결합할 것 (단 최종 결과는 id,phone,country,city,is_marketing_agree컬럼만 출력하고, 거주 국가 기준 알파벳 순으로 정렬할 것).

```sql
(SELECT u.id,u.phone,u.country,u.city,u.is_marketing_agree
FROM users u
WHERE u.is_marketing_agree = 1 AND u.country = 'USA')
UNION ALL
(SELECT u.id,u.phone,u.country,u.city,u.is_marketing_agree
FROM users u
WHERE u.is_marketing_agree = 0 AND u.country = 'France')
ORDER BY country;
```

3. UNION을 활용하여 orderdetails와 products full outer join으로 결합하여 출력할 것.
   (어떻게 하면 UNION만으로 FULL OUTER JOIN을 구현할 수 있을지?)

```sql
(SELECT *
FROM orderdetails od
LEFT JOIN products p ON od.product_id = p.id)
UNION
(SELECT *
FROM orderdetails od
RIGHT JOIN products p ON od.product_id = p.id);
```

그래서 이상의 코드는 FULl OUTER JOIN을 사용하면 그만이기 때문에 원리 말고는 가치가 없다.

# Sub Query

- SQL의 쿼리 결과를 테이블 처럼 사용하는 쿼리 내부의 쿼리.
- 이상의 학습 내용과는 다르게, 기존에는 데이터를 결합할 때 이미 존재하는 테이블에 접근하여 결합을 시도했다.
  하지만 이제부터는 기존 테이블을 편집하여 만든 결과값을 기준으로 다시 쿼리를 실행하는 형태로 수업이 이루어진다.

즉, 개발자가 작성한 쿼리를 실행하여 나온 결과값을 테이블처럼 사용하거나 조건 또는 값으로 사용할 수 있을까?
와 관련된 내용

서브 쿼리는 SELECT 문 내의 여러 곳에서 사용이 가능한데, 사용하는 워치에 따라 불리는 이름이 다양하다.
그래서 서브 쿼리 하나로 퉁치면 안되고 어떤 서브쿼리인지 아는게 중요하다 SQLD 시험에도 등장

예제 : products에서 제품명과, 정상 가격을 모두 불러오고, 평균 정상 가격을 새로운 컬럼으로 각 행마다 출력하시오.

```sql
SELECT name, price,
(SELECT AVG(price) FROM products) AS avgProducts
FROM products
```

`SELECT AVG(price) FROM products;` 의 결과값은 : 전체 price들의 총합을 row개수만큼 나눈 평균값에 해당한다.

그리고 이상의 select avg(price) from products 쿼리를 실행했을 때 row 1 = column = 1 인 테이블이 생성

그리고 이 단일한 결과값이 나온 테이블을

```sql
SELECT name, price,
(SELECT AVG(price) FROM products) AS avgProducts
FROM products
```

이렇게 적용시키면 전체 테이블은 name,price,avgProducts로 이루어진 세개의 컬럼을 지닌 테이블이 나오게 된다.
서브 쿼리의 결과가 하나의 값만 있기 대문에 모든 row에 select avg(price) from products의 결과값이 붙어서 출력된다.

이처럼 *SELECT 절에는 `단일 값을 반환` 하는 서브 쿼리가 올 수 있는데, 이를 `스칼라(Scalar) 서브 쿼리` 라고 한다.
![alt text](image-3.png)
결과 화면의 마지막 컬럼처럼 스칼라 서브 쿼리는 신규 컬럼으로 추가되어 모든 행에 *단일 값을 출력\_ 한다.

```sql
SELECT name, price, 100.00 as fakePrice
from products;
# 오류 나는 예시
select name, price, avg(price) as AvgPrice FROM products;
```

이상의 경우처럼 첫 행만 출력되거나 DB에 따라서는 GROUP BY가 없는 상태라서 오류가 발생한다. 애초에 집계함수

- 유의 사항 : 스칼라 서브 쿼리를 작성할 때 _단일 값이 반환되도록 작성_ 해야한다는 점. 만약에 2 개 이상의 집계 값을 기존 테이블에 추가하고 싶다면 스칼라 서브 쿼리를 나누어서 작성해야 한다.

정상가 기준의 avgPrice avgDiscountPrice도 컬럼에 추가하고 싶다면 서브 쿼리 두 개가 병렬로 있어야 한다.

```sql
select name, price,(select round(avg(price),2)from products) as avgproducts,
(select round(avg(discount_price),2) from products) as avgDiscountPrice
from products;
```

예제 : users에서 city 별 회원 수를 카운트 하고, 회원 수가 3 명 이상인 도시명과 회원 수를 출력할 것(단, 회원 수를 기준으로 내림 차순 정렬)

```sql
SELECT *
FROM (select city ,COUNT(DISTINCT id) AS userCnt FROM users
GROUP BY city)
WHERE userCnt > 2
ORDER BY userCnt DESC;
```

그리고 서브쿼리를 적용했을 때는 이상과 같이 작성할 수 있다

주요 사항으로는 1. FROM 절 내에 서브 쿼리가 들어갔다는 점이다. -> 편집이 이루어진 새로운 테이블을 기준으로 새로운 쿼리문을 작성했다는 부분

2. 이상과 같이 from 절 내에 서브 쿼리가 들어가는 것을 인라인 뷰(Inline View)라고 표현한다.

## Inline View

특징 :

1. 인라인 뷰 내에는 도 다른 서브 쿼리가 개수 제한 없이 중첩적으로 들어갈 수 있음.
2. 인라인 뷰의 서브 쿼리는 괄호 안에 작성한 쿼리의 결과값 자체를 테이블에 존재하는 데이터로 간주하고, 이에 대한 로직을 수행한다.
   그래서 위의 예시를 보면 서브 쿼리의 연산 결과로 city / userCnt 라는 두 개의 컬럼이 생긴다는 것을 알 수 있다. 즉, city / userCnt라는 컬럼을 가지고 있는 테이블을 기준으로 select \* 을 수행했기 때문에 최종 결과값에서도 city / userCnt가 있는 것이고, userCnt 라는 컬럼이 존재하기 때문에 서브 쿼리 바깥에서 WHERE userCnt > 2와 같은 조건을 연산하는 것도 가능하다.

그리고 HAVING 적용 버전과의 차이점은 HAVING을 통해 필터링 하는 경우는 GROUP BY 이후에 HAVING이 이루어지는 반면 inline view에서는 가장 먼저 연산이 수행된다는 점이다.

## WHERE 절 내부의 서브쿼리

예제 : orders에서 staff를 활용하여 last_name의 값이 Kyle이나 scott인 직원의 담당 주문을 출력한다.(서브 쿼리 활용)

```sql
SELECT *
FROM orders
WHERE staff_id IN(SELECT id FROM staff WHERE last_name IN ('Kyle','Scott'))
```

Kyle의 staff_id = 3 이고 Scott의 staff_id = 5이다. 이를 가지고 orders 테이블의 staff_id와 연결하여 원하는 주문 정보만 조회한 경우가 된다. WHERE staff_id IN ()으로 작성했을 때 () 내부에 여러 개의 데이터를 집어넣을 수 있다는 점은 우리가 알고 있는 부분이다. 그렇다면 서브쿼리 내부의 결과물은 3 , 5가 출력되어서 나왔을 것이고,

```sql
SELECT *
FROM orders
WHERE staff_id IN(3,5)
```

와 같은 연산 결과가 나온다, 그렇다면 서브 쿼리를 작성하는데에 있어서 중요한 점은 서브 쿼리의 최종 결과값이 어떻게 될 것인가. 이다.

예제 : products에서 할인 가격이 가장 비싼 제품을 출력하시오.
순서 :

1. 가장 비싼 가격이 출력된다 `SELECT * , MAX(discount_price) FROM products;` -> data 기준으로 double / float 중 하나
2. 이상의 결과값을 가지고 전체 products 테이블에 대한 조건을 설정할 수 있다.

```sql
select *
from products where discount_price = SELECT * , (MAX(discount_price) FROM products);
```

그렇다면 MAX() 적용값은 이미 product 테이블의 discount*price에 명백히 존재하는 데이터 이다.
그 부분을 서브쿼리로 삼아서
select *
`from products where discount_price = SELECT _ , (MAX(discount_price) FROM products);`
이렇게 작성 한다면,
select \*
from products where discount_price = 499.99;
와 같은 의미가 된다.

예제 : orders에서 주문 월 (order_date 컬럼 활용) 2015년 7월인 주문 정보를, orderdetails에서 개별 주문 수량(quantity)이 50이상인 정보를 각각 서브쿼리로 작성하고, inner join을 활용하여 작성

```sql
SELECT *
FROM	(

	SELECT * FROM orders
	WHERE order_date >= '2015-07-01' AND order_date < '2015-08-01'
) o
JOIN
(
	SELECT * FROM orderdetails
	WHERE quantity > 49
) od
ON o.id = od.order_id
;
```

## 서브 쿼리 정리

서브 쿼리는 결과값을 메인 쿼리에서 값이나 조건으로 사용하고 싶을 떄 사용.
select / from / where 등 사용 위치에 따라 불리는 이름이 다르다. 공통점은 그냥 ()내에 쿼리문을 작성한다는 점이다.

1. select 절에서의 사용

- select에서는 단일 집계 값을 신규 컬럼으로 추가하기 위해 서브쿼리를 사용. 여러 개의 쿼리를 추가 하고 싶다면
  _여러 개의 서브 쿼리_ 를 작성하면 된다. select의 서브 쿼리는 메인 쿼리의 from에서 사용된 테이블이 아닌
  테이블 도 사용 가능하기 때문에 불필요한 JOIN을 줄일 수 있다.

- Scalar Sub Query라고 한다.

2. FROM 절에서 사용

   - FROM 절에서 사용되는 서브 쿼리는 Inline View라고 하며, 마치 테이블처럼 서브 쿼리의 결과값을 사용할 수 있다.
     FROM에서 두 개 이상의 서브 쿼리를 활용할 경우 JOIN을 수행할 수도 있다. 이때 Inline View에서는 마치 테이블을 하나 생성하는 것과 같기 때문에 테이블 명을 지어주는 것이 중요하다.

   FROM에서 서브 쿼리를 적절히 활용하면 적은 연산으로 결과값을 출력할 수 있다는 장점이 있다.

3. WHERE 절에서 사용

- WHERE 에서 필터링을 위한 조건 값을 설정하는데 서브쿼리를 활용할 수 있다. 그래서 결과값이 하나라면 = 를 쓸 것이고
  복수의 결과값이라면 IN()을 쓸 수도 있다. 특히 IN 연산자를 통해 서브 쿼리로 다중 컬럼 비교를 할 때는 서브 쿼리에서 추출하는 컬럼의 개수와 WHERE에서 작성하는 필터링 대상 컬럼의 개수가 일치해야 한다.

연습 문제

1. products를 풀 스캔하고, 할인 가격의 최대값 대비 해당 제품의 할인 가격의 비율을 구해 ratioPerMaxprc 컬럼명으로 추가할 것(단, 추가 컬럼이 소수점 셋째 자리까지만 표기될 수 있도록 함수를 사용할 것)

```sql
SELECT *,round(discount_price /(SELECT MAX(discount_price)FROM products),3)
FROM products ;
```

2. users에서 staff 테이블을 활용하여 거주 국가가 Korea나 Italy이면서 생년 월일이 1990-01-01 이전인* 회원이자 직원* 인 사람의 정보를 출력할 것(JOIN / 서브 쿼리를 활용할 수 있다.) 단, 회원 아이디 / 연락처 / 거주국가 / 직원 아이디 / 성 / 이름 컬럼을 출력할 것.

```sql
SELECT u.id,u.phone,u.country,s.id,s.last_name,s.first_name
FROM (
	SELECT * FROM users WHERE country IN ('Korea','Italy')
) u
JOIN(
	SELECT * FROM staff WHERE birth_date < '1990-01-01'
) s
ON u.id = s.user_id;
```

3. users를 활용해 country 별 회원 수를 카운트하고 5명 이상인 국가만 출력할 것(단, 회원 수 기준 내림차순으로 정렬할 것)

```sql
SELECT COUNT(id) AS Cid, country
FROM users u
GROUP BY country
HAVING Cid >= 5
ORDER BY Cid DESC;
```

내가 한것

```sql
SELECT * FROM
	(
	SELECT country, COUNT(DISTINCT id) AS userCnt
	FROM users
	GROUP BY country
	) u
	WHERE userCnt >= 5 ORDER BY userCnt DESC;
```

서브 쿼리 적용 4. products에서 정상 가격이 가장 저렴한 제품의 정보를 모두 출력할 것

```sql
SELECT *
FROM products
WHERE price = (SELECT MIN(price)FROM products);
```

5. orders와 users를 활용해 2016년도에 주문 이력이 있는 (order_date 활용) 회원의 정보를 모두 출력할 것.

```sql
SELECT *
FROM(
SELECT *
FROM orders o
WHERE o.order_date BETWEEN '2016-01-00' AND '2016-12-31'
) o
JOIN (
SELECT *
FROM users u
) u
ON u.id = o.user_id
GROUP BY u.id
```

내가 한것

```sql
SELECT * FROM users
WHERE id IN (SELECT user_id FROM orders
WHERE YEAR(order_date) = 2016)
```

수정 한 것
